<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>CSIDE - Standards Track</title><link href="https://connetinfotech.github.io/cside-ce/" rel="alternate"></link><link href="https://connetinfotech.github.io/cside-ce/feeds/standards-track.atom.xml" rel="self"></link><id>https://connetinfotech.github.io/cside-ce/</id><updated>2024-03-28T11:44:00+08:00</updated><entry><title>[2] Boot modes for starting up the application</title><link href="https://connetinfotech.github.io/cside-ce/2-boot-modes-for-starting-up-the-application.html" rel="alternate"></link><published>2024-03-28T11:44:00+08:00</published><updated>2024-03-28T11:44:00+08:00</updated><author><name>Jiang ZiJian</name></author><id>tag:connetinfotech.github.io,2024-03-28:/cside-ce/2-boot-modes-for-starting-up-the-application.html</id><summary type="html">&lt;h2 id="abstract"&gt;Abstract&lt;/h2&gt;
&lt;p&gt;This document proposes various boot modes for starting up the application.&lt;/p&gt;
&lt;h2 id="proposal"&gt;Proposal&lt;/h2&gt;
&lt;p&gt;The document outlines four startup modes for the application: &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;safe&lt;/code&gt;,
&lt;code&gt;dev&lt;/code&gt;, and &lt;code&gt;safe-dev&lt;/code&gt;. In &lt;code&gt;normal&lt;/code&gt; mode, the application starts up using the user
configuration. Safe mode assumes that startup failure is caused by configuration
corruption, so …&lt;/p&gt;</summary><content type="html">&lt;h2 id="abstract"&gt;Abstract&lt;/h2&gt;
&lt;p&gt;This document proposes various boot modes for starting up the application.&lt;/p&gt;
&lt;h2 id="proposal"&gt;Proposal&lt;/h2&gt;
&lt;p&gt;The document outlines four startup modes for the application: &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;safe&lt;/code&gt;,
&lt;code&gt;dev&lt;/code&gt;, and &lt;code&gt;safe-dev&lt;/code&gt;. In &lt;code&gt;normal&lt;/code&gt; mode, the application starts up using the user
configuration. Safe mode assumes that startup failure is caused by configuration
corruption, so the application starts up using a temporary folder and default
configuration. In &lt;code&gt;dev&lt;/code&gt; mode, the logging level is adjusted to print debug
information. Finally, in &lt;code&gt;safe-dev&lt;/code&gt; mode, the application starts up using a
temporary folder and default configuration while also printing debug information.&lt;/p&gt;
&lt;h2 id="rational"&gt;Rational&lt;/h2&gt;
&lt;p&gt;By offering multiple boot modes, users have the flexibility to choose the
startup behavior that best suits their needs or resolves any issues they may
encounter. The inclusion of &lt;code&gt;safe&lt;/code&gt; modes (&lt;code&gt;safe&lt;/code&gt; and &lt;code&gt;safe-dev&lt;/code&gt;) ensures that the
application can recover gracefully from potential configuration corruption or
other startup failures, minimizing downtime and providing a smoother user
experience. The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;safe-dev&lt;/code&gt; modes cater to developers or administrators
by enabling verbose logging and debug information, which can be invaluable for
diagnosing and resolving issues during development or troubleshooting.&lt;/p&gt;</content><category term="Standards Track"></category><category term="Standards Track"></category><category term="Draft"></category></entry><entry><title>[1] An extensible plugin system for GUI based IDE platform</title><link href="https://connetinfotech.github.io/cside-ce/1-an-extensible-plugin-system-for-gui-based-ide-platform.html" rel="alternate"></link><published>2024-03-26T14:45:00+08:00</published><updated>2024-03-26T14:45:00+08:00</updated><author><name>Jiang ZiJian</name></author><id>tag:connetinfotech.github.io,2024-03-26:/cside-ce/1-an-extensible-plugin-system-for-gui-based-ide-platform.html</id><summary type="html">&lt;h2 id="abstract"&gt;Abstract&lt;/h2&gt;
&lt;p&gt;This document propose an extensible plugin system for GUI based IDE platform.&lt;/p&gt;
&lt;h2 id="rationale"&gt;Rationale&lt;/h2&gt;
&lt;p&gt;Looking at the IDEs that have survived for a long time and developed well,
like Eclipse(2001-), Visual Studio Code(2015-), we can all find that they
all have the characteristics of a plug-in system. An …&lt;/p&gt;</summary><content type="html">&lt;h2 id="abstract"&gt;Abstract&lt;/h2&gt;
&lt;p&gt;This document propose an extensible plugin system for GUI based IDE platform.&lt;/p&gt;
&lt;h2 id="rationale"&gt;Rationale&lt;/h2&gt;
&lt;p&gt;Looking at the IDEs that have survived for a long time and developed well,
like Eclipse(2001-), Visual Studio Code(2015-), we can all find that they
all have the characteristics of a plug-in system. An extensible plugin system
for a GUI-based Integrated Development Environment (IDE) platform offers
several key benefits as customization, scalability, flexibility, community
contribution, future-proofing.&lt;/p&gt;
&lt;p&gt;This characteristic has indeed proven to be a crucial factor in their sustained
development and widespread adoption. It's a testament to the benefits that
such a system brings to both developers and the overall ecosystem of software
development.&lt;/p&gt;
&lt;h2 id="influences"&gt;Influences&lt;/h2&gt;
&lt;p&gt;This proposal was put together after having studied the following softwares
and libraries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spyder&lt;/li&gt;
&lt;li&gt;Eclipse&lt;/li&gt;
&lt;li&gt;Visual Studio Code&lt;/li&gt;
&lt;li&gt;Python Packaging User Guide - Creating and discovering plugins&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="components"&gt;Components&lt;/h2&gt;
&lt;p&gt;The basic components that pull IDE together are &lt;code&gt;CNPluginWidget&lt;/code&gt; and &lt;code&gt;CNPlugin&lt;/code&gt;.
Every widget you see belongs to a plugin. And every big feature you use is the
process of a group of plug-ins collaborating.&lt;/p&gt;
&lt;h3 id="cnplugin"&gt;CNPlugin&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CNPlugin&lt;/code&gt; plays the controller role of MVC architecture. It manages the
interaction between the plugin's widgets (&lt;code&gt;CNPluginWidgets&lt;/code&gt; or Qt widgets)
and the logic necessary to implement the desired features. It also exposes
a public API that other parts of the IDE or other plugins can use to interact
with this functionality. In practise it should be singleton and only can be
registered into the system once.&lt;/p&gt;
&lt;h3 id="cnpluginwidget"&gt;CNPluginWidget&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CNPluginWidget&lt;/code&gt; represent the user interface components/widgets within the
IDE that are associated with a specific plugin. These widgets provide the
interface through which users interact with the functionality provided by
the plugin.&lt;/p&gt;
&lt;h2 id="features_1"&gt;Features&lt;/h2&gt;
&lt;h3 id="inter-plugin-communication"&gt;Inter-Plugin Communication&lt;/h3&gt;
&lt;p&gt;As plugins are designed to isolate different aspects of features, collaboration
between plugins becomes crucial, especially for larger functionalities. Therefore,
it is necessary for plugins to monitor each other's lifecycle to establish and
dismantle communication channels effectively (through Qt signal slot connections).&lt;/p&gt;
&lt;p&gt;One plugin object can utilize the &lt;code&gt;onPluginAvailable&lt;/code&gt; and &lt;code&gt;onPluginTeardown&lt;/code&gt;
decorators to register a method for listening to another plugin's lifecycle.
The &lt;code&gt;onPluginAvailable&lt;/code&gt; decorated method will be invoked immediately after a
specific plugin becomes available, while the &lt;code&gt;onPluginTeardown&lt;/code&gt; decorated method
will be called just before the plugin is torn down. Also &lt;code&gt;plugin&lt;/code&gt; and
&lt;code&gt;isPluginAvailable&lt;/code&gt; is used for fetch other plugin.&lt;/p&gt;
&lt;h3 id="plugin-level-configuration"&gt;Plugin level Configuration&lt;/h3&gt;
&lt;p&gt;Each plugin possesses its own scope of configuration to store and load its options.
These options are automatically serialized into the &lt;code&gt;app.ini&lt;/code&gt; file located in the
&lt;code&gt;.cside&lt;/code&gt; folder within the USER directory. This functionality is particularly
convenient, as plugins invariably require storing and loading various user
settings, such as the editor's font size, the last opened directory, or shortcut
key sequences. Since we employ the INI configuration format here, the plugin's
name serves as the default section for its options.&lt;/p&gt;
&lt;p&gt;A plugin object can utilize the &lt;code&gt;onConfChange&lt;/code&gt; decorator to register a method for
listening to changes in option values. Additionally, they can use &lt;code&gt;option&lt;/code&gt;,
&lt;code&gt;options&lt;/code&gt;, &lt;code&gt;setOption&lt;/code&gt;, &lt;code&gt;removeOption&lt;/code&gt;, and &lt;code&gt;optionDefault&lt;/code&gt; methods to
create, read, update, and delete option values.&lt;/p&gt;
&lt;p&gt;User can set plugin's default configuration through its class attribute
&lt;code&gt;A_CONF_DEFAULTS&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="widgets-within-plugin"&gt;Widgets within plugin&lt;/h3&gt;
&lt;p&gt;Widgets within plugins are essentially plain Qt widgets equipped with the
ability to read and write options, much like the plugins themselves.&lt;/p&gt;
&lt;h2 id="faq_1"&gt;FAQ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Is there order in plugins initialization and teardown?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Answer: No, in the context of plugin initialization and teardown, there is no
strict order enforced. The rationale behind this approach is to promote a design
philosophy where each plugin operates independently, without strong dependencies
on others. Plugins are expected to determine their own activation based on their
environment. This design principle enhances the system's flexibility and reduces
inter-plugin dependencies, ultimately contributing to improved stability and
maintainability.&lt;/p&gt;</content><category term="Standards Track"></category><category term="Standards Track"></category><category term="Final"></category></entry></feed>